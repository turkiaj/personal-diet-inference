---
title: "Personal recommendation"
output: html_notebook
---

```{r setup, include=FALSE}
library(knitr)

knitr::opts_chunk$set(echo = TRUE, fig.align="center", fig.pos = 'H')

# this allows using tikz rendering for plots with "dev=tikz"
knit_hooks$set(plot = function(x, options) {
  if ('tikz' %in% options$dev && !options$external) {
    hook_plot_tex(x, options)
  } else hook_plot_md(x, options)
})

# Fix seed for random number generator for getting consistent results in kmeans etc.
fixed_seed <- 678

# Load common MEBN package
source("mebn/v3/MEBNv3.r")

```

```{r data_loading, echo=FALSE, message=FALSE, warning=FALSE}
library(lubridate)
library(dplyr)
library(tidyr)

# Read the data description
diet_datadesc <- read.csv(file="data/diet_data_description.csv", header = TRUE, sep = ";", dec = ",")

dialysis_datadesc <- diet_datadesc[diet_datadesc$Dialysis==TRUE,]

# Read the actual data matching the description
dialysis <- read.csv(file="data/DIALYSIS_imputed_palb.csv", sep=";", dec=",")

# Define factors
dialysis$potilas <- factor(dialysis$potilas)
dialysis$nesterajoitus <- factor(dialysis$nesterajoitus)
dialysis$verenpainelaakitys <- factor(dialysis$verenpainelaakitys)
dialysis$verenrasvojen_laakitys <- factor(dialysis$verenrasvojenlaakitys)
dialysis$mielialalaakitys <- factor(dialysis$mielialalaakitys)
dialysis$fosforinsitoja <- factor(dialysis$fosforinsitoja)
dialysis$kaliuminsitoja <- factor(dialysis$kaliuminsitoja)
dialysis$anemian_hoito <- factor(dialysis$anemianhoito)
dialysis$diabeteslaakitys <- factor(dialysis$diabeteslaakitys)
dialysis$antibiootti <- factor(dialysis$antibiootti)
dialysis$marevan <- factor(dialysis$marevan)
dialysis$nesteenpoisto <- factor(dialysis$nesteenpoisto)
dialysis$ummetuslaake <- factor(dialysis$ummetuslaake)
dialysis$verenohennus <- factor(dialysis$verenohennus)
dialysis$akt_dvit <- factor(dialysis$aktdvit)
dialysis$renavit <- factor(dialysis$renavit)
dialysis$cad <- factor(dialysis$cad)

# Calculate missing E% for fats 
# https://fineli.fi/fineli/fi/ravintotekijat/2331

dialysis$mufaepros <- dialysis$mufa * 9 / dialysis$energiakcal * 100 # Rasvan energiakerroin on 37 kJ/g (9 kcal/g)
dialysis$pufaepros <- dialysis$pufa * 9 / dialysis$energiakcal * 100 # Rasvan energiakerroin on 37 kJ/g (9 kcal/g)
# dialysis$safaepros already exists in data

dialysis$sakkaroosiepros <- dialysis$sakkaroosi * 4 / dialysis$energiakcal * 100 # Sakkaroosin energia-arvo on 17 kJ/g (4 kcal/g)

# gender: female = 1, male = 0
# already done
#dialysis$sukupuoli <- factor(ifelse(dialysis$sukupuoli == "nainen", 1, 0))

# Days between laboratory test and food record interview
dialysis$responsedays <- difftime(as.Date(dialysis$labraaika, '%d.%m.%Y'), as.Date(dialysis$ravhaastaika, '%d.%m.%Y'), units = c("days"))

responsedays_desc <- dialysis_datadesc[dialysis_datadesc$Name=="sukupuoli",]
responsedays_desc$Order <- 0 # OMITTED !!
responsedays_desc$Distribution <- "Integer"  # Filter this out from normalization etc.
responsedays_desc$Name <- "responsedays"
responsedays_desc$Unit <- "days"
responsedays_desc$Description <- "responsetime"
responsedays_desc$Descriptionfin <- "vasteaika"
responsedays_desc$Condition <- 0
dialysis_datadesc <- rbind(dialysis_datadesc, responsedays_desc)

# important: dataset is ordered by successive patients and observations so that estimation works correctly
dialysis <- dialysis[order(dialysis$potilas, dialysis$havainto),]

# remove patients with one observation only

# dialysis
patients_with_two_obs <- dialysis %>% 
  group_by(potilas) %>% 
  summarise(havainto_sum = sum(havainto)) %>%
  filter(havainto_sum == 3) %>%
  select(potilas) %>%
  unlist() %>% as.vector()

dialysis <- dialysis[dialysis$potilas %in% patients_with_two_obs,]

# - reset patient levels
dialysis$potilas <- factor(dialysis$potilas)

# Define how to iterate through the graph
# - same targets
dialysis_predictors <- dialysis_datadesc[dialysis_datadesc$Order==100,]
dialysis_targets <- dialysis_datadesc[dialysis_datadesc$Order==200,]

```


```{r}

mean(dialysis[dialysis$ika < 40,]$palb)
dialysis[dialysis$ika < 40,]$palb

mean(dialysis[dialysis$ika >= 40 & dialysis$ika <= 69,]$palb)
sd(dialysis[dialysis$ika >= 40 & dialysis$ika <= 69,]$palb)

mean(dialysis[dialysis$ika >= 70,]$palb)
sd(dialysis[dialysis$ika >= 70,]$palb)

mean(dialysis$pk)
sd(dialysis$pk)

mean(dialysis$fppi)
sd(dialysis$fppi)

```

```{r}
library(kableExtra)

example_datadesc <- diet_datadesc[diet_datadesc$Dialysis==TRUE | diet_datadesc$Sysdimet==TRUE,]
example_predictors <- example_datadesc[example_datadesc$Order==100 & example_datadesc$Condition >= 100,]

# Mean and SD for dialysis data
example_predictors$dialysis_mean <- 0
example_predictors$dialysis_sd <- 0

example_predictors[example_predictors$Dialysis==TRUE,]$dialysis_mean <- sapply(example_predictors[example_predictors$Dialysis==TRUE,]$Name, function(x) format(round(mean(dialysis[[x]]), example_predictors[example_predictors$Name==x,]$Decimals), nsmall=example_predictors[example_predictors$Name==x,]$Decimals))
example_predictors[example_predictors$Dialysis==TRUE,]$dialysis_sd <- sapply(example_predictors[example_predictors$Dialysis==TRUE,]$Name, function(x) format(round(sd(dialysis[[x]]), example_predictors[example_predictors$Name==x,]$Decimals), nsmall=example_predictors[example_predictors$Name==x,]$Decimals))

# Mean and SD for sysdimet data

sysdimet <- read.csv(file="data/SYSDIMET_epros.csv", sep=";", dec=",")

# Only control cohort of Sysdimet
sysdimet <- sysdimet[sysdimet$ryhma=='kontrolli',]

example_predictors$sysdimet_mean <- 0
example_predictors$sysdimet_sd <- 0

example_predictors[example_predictors$Sysdimet==TRUE,]$sysdimet_mean <- sapply(example_predictors[example_predictors$Sysdimet==TRUE,]$Name, function(x) format(round(mean(sysdimet[[x]]), example_predictors[example_predictors$Name==x,]$Decimals), nsmall=example_predictors[example_predictors$Name==x,]$Decimals))

example_predictors[example_predictors$Sysdimet==TRUE,]$sysdimet_sd <- sapply(example_predictors[example_predictors$Sysdimet==TRUE,]$Name, function(x) format(round(sd(sysdimet[[x]]), example_predictors[example_predictors$Name==x,]$Decimals), nsmall=example_predictors[example_predictors$Name==x,]$Decimals))

example_predictors$Unit <- gsub("%","\\%",example_predictors$Unit)

example_predictors.df <- example_predictors %>% 
    mutate(Predictor = paste0(Description, " (", Unit, ")")) %>%
    mutate(Range = case_when(
        is.na(Lowerbound) | is.na(Upperbound) ~ "",
        Unit == "" ~ paste0(Lowerbound, " - ", Upperbound),
        Unit != "" ~ paste0(Lowerbound, " - ", Upperbound)
    )) %>%
    mutate(RI = case_when(
        is.na(Recommendation) ~ "",
        Unit == "" ~ as.character(Recommendation),
        Unit != "" ~ as.character(Recommendation)
    )) %>%
    mutate(Study = case_when(
        Dialysis == TRUE & Sysdimet == TRUE ~ "In both studies",
        Dialysis == TRUE & Sysdimet == FALSE ~ "Dialysis only",
        Dialysis == FALSE & Sysdimet == TRUE ~ "Sysdimet only",
    )) %>%
    mutate(Order = case_when(
        Study == "In both studies" ~ 1,
        Study == "Dialysis only" ~ 2,
        Study == "Sysdimet only" ~ 3
    )) %>%
    mutate(Sysdimet = ifelse(sysdimet_mean > 0, paste0(sysdimet_mean, "\\pm", sysdimet_sd), "-")) %>%
    mutate(Dialysis = ifelse(dialysis_mean > 0, paste0(dialysis_mean, "\\pm", dialysis_sd), "-")) %>%
    arrange(Order) %>%
    select(Predictor, Range, RI, Sysdimet, Dialysis)

kable(example_predictors.df, format = "html", escape = F, booktabs = T, row.names = FALSE, 
      caption = "Nutrients that were analyzed and personalized in each of the studied examples.",
   col.names = c("Nutrient", "Proposed range", "RI", "Sysdimet", "Dialysis")) %>%
   add_header_above(c("","","", "Sample mean \\pmSD" = 2)) %>%
   kable_styling(latex_options="scale_down") %>%  
   kable_styling(latex_options = c("basic", "condensed"), full_width = FALSE) %>%
   row_spec(0,bold=TRUE) 
   # %>% save_kable(file = "tables/studied_nutrients.pdf", keep_tex = TRUE)


example_predictors.df
```

```{r fig.width=10, fig.height=7}
source("mebn/v3/MEBNv3.r")

library(igraph)
library(ggraph)

initial_graph <- mebn.fully_connected_bipartite_graph(dialysis_datadesc)

bipa_layout <- layout_as_bipartite(initial_graph, types = V(initial_graph)$type == "100", hgap = 1, vgap = 1)

# - flip layout sideways, from left to right
bipa_layout <- cbind(bipa_layout[,2], bipa_layout[,1])
V(initial_graph)[V(initial_graph)$type == "100"]$label.degree = pi # left side
V(initial_graph)[V(initial_graph)$type == "200"]$label.degree = 0 # right side

ggraph(initial_graph, layout = bipa_layout) +
  geom_edge_link(colour = "#AAAAAA") +
  geom_node_label(nudge_x = 0.05, aes(label = description, colour = "#000000")) +
  theme_bw() + 
  theme(axis.text.y = element_blank(), axis.text.x = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  labs(x = element_blank(), y = element_blank())

```

```{r graph_with_gamma_qr_mvcross_two_levels, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
source("mebn/v3/MEBNv3.r")

no_holdout <- rep(0, nrow(dialysis))

initial_graph <- mebn.fully_connected_bipartite_graph(dialysis_datadesc)

# add the dialysis treatment type as a grouping factor
dialysis$hoitoryhma <- as.factor(dialysis$hoitomuoto)

# and sort the data by treatment/patient/observation
dialysis <- dialysis[order(dialysis$hoitoryhma, 
                                           dialysis$potilas, dialysis$havainto),]

dialdiet_gamma_mv3_two_level <- mebn.bipartite_two_level_multivariate(
                                   reaction_graph = initial_graph, 
                                   inputdata = dialysis,
                                   targetdata = no_holdout,
                                   predictor_columns = dialysis_predictors, 
                                   assumed_targets = dialysis_targets, 
                                   group_column = "hoitoryhma",
                                   subject_column = "potilas",
                                   local_estimation = mebn.two_level_multivariate_sampling,
                                   local_model_cache = 
                                     "models/dialysis/BLMM_gamma_mv_cross/two_levels", 
                                   stan_model_file = 
                                     "mebn/v3/BLMM_gamma_two_level_centered.stan",
                                   normalize_values = TRUE)

write.graph(dialdiet_gamma_mv3_two_level, 
            "graphs/dialysis_gamma_two_level_grouping.graphml", "graphml")
```


```{r}
# Model diagnostics
library(rstan)
library(bayesplot)

multivariate_model_name <- paste0(dialysis_targets$Name, collapse = "_")

target_blmm1 <- mebn.get_localfit(multivariate_model_name, "models/dialysis/BLMM_gamma_mv_cross/two_levels/warmup_1000_draws_2000")
target_blmm <- mebn.get_localfit(multivariate_model_name, "models/dialysis/BLMM_gamma_mv_cross/two_levels")

stan_diag(target_blmm)
stan_rhat(target_blmm)

sumstats <- summary(target_blmm)

eff <- na.omit(sumstats$summary[,9])
c(min(eff),mean(eff),max(eff))  # 4.130193  649.232663 8454.864067 (1000/3000 centered)

rhat <- na.omit(sumstats$summary[,10])
c(min(rhat),mean(rhat),max(rhat)) # 0.9994999 1.0097500 1.4819038 (1000/3000 centered)

sumstats1 <- summary(target_blmm1)

eff1 <- na.omit(sumstats1$summary[,9])
c(min(eff1),mean(eff1),max(eff1))  # 3.2155  104.4737 5207.7537  originaali

rhat1 <- na.omit(sumstats1$summary[,10])
c(min(rhat1),mean(rhat1),max(rhat1)) # 0.9989995 1.1018058 1.9848125

sumstats[startsWith(sumstats$summary, "personal_effect"),]

startsWith(sumstats$summary[1,], "personal_effect")

pe_summary1 <- summary(target_blmm1, pars="personal_effect")
pe_summary <- summary(target_blmm, pars="personal_effect")

eff1 <- na.omit(pe_summary1$summary[,9])
c(min(eff1),mean(eff1),max(eff1))

rhat_pe <- na.omit(pe_summary$summary[,10])
c(min(rhat_pe),mean(rhat_pe),max(rhat_pe))

eff <- na.omit(pe_summary$summary[,9])
c(min(eff),mean(eff),max(eff))

rhat <- na.omit(pe_summary$summary[,10])
c(min(rhat),mean(rhat),max(rhat))

mcmc_trace(target_blmm1, pars = c("beta[1,1]"))
mcmc_trace(target_blmm, pars = c("beta[1,2]"))


```

```{r rmse}
library(rstan)

target_blmm <- mebn.get_localfit("pk_fppi_palb", "models/dialysis/BLMM_gamma_mv_cross/two_levels/")

params <- rstan::extract(target_blmm, pars="Y_rep")
patients <- levels(dialysis$potilas)
obs <- nrow(dialysis)

NRMSE <- NULL

for (i in 1:obs)
{
  subject_nrmse <- NULL

  for (target in 1:nrow(dialysis_targets))
  {
    rep_response <- params$Y_rep[,target,i]
    
    target_name <- dialysis_targets[target,]$Name

    # true value for observation
    true_response <- dialysis[i,][target_name]

    # Expected value of repeated concentration is compared to the true concentration observation
    
    conc_NRMSE <- abs(mean(rep_response) - mean(true_response[1,]))/mean(true_response[1,])
    
    if (is.null(subject_nrmse)) {
      subject_nrmse <- conc_NRMSE
    } 
    else
    {
      subject_nrmse <- cbind(subject_nrmse, conc_NRMSE)
    }
  }
  
  if (is.null(NRMSE)) {
    NRMSE <- subject_nrmse
  } 
  else
  {
    NRMSE <- rbind(NRMSE, subject_nrmse)
  }
  
}

colnames(NRMSE) <- dialysis_targets$Name
NRMSE_means <- colMeans(NRMSE)
NRMSE_means

```

```{r dialysis_gamma_mv_cross_2levels_ppc, echo=FALSE, message=FALSE, warning=FALSE, eval=TRUE, cache=TRUE, fig.cap="Posterior predictive check of the model where three concentrations and their parameters are stacked into one univariate model for estimating cross-model correlations."}
source("mebn/v3/MEBNv3.r")

p <- mebn.multivariate_dens_overlays("models/dialysis/BLMM_gamma_mv_cross/two_levels/", dialysis_targets, dialysis) 
p

ggsave("figures/dialysis_ppc_mv3_two_levels_cross.pdf", plot = p, width = 4, height = 4)

```

```{r extract_personal_generative_models, eval=FALSE, echo=FALSE}
source("mebn/v3/MEBNv3.r")

# Extract generative models for patients with data from personal grouping

# - latent parameters from this model
latent_parameter_modeldir <- "models/dialysis/BLMM_gamma_mv_cross/two_levels"

# - use these predictors and targets
target_variables <- dialysis_targets

# - output personal generative models (graphml + rv samples) in this dir
graph_dir <- "graphs/dialysis/mv3_cross_two_levels/"

# add the dialysis treatment type as a grouping factor
dialysis$hoitoryhma <- as.factor(dialysis$hoitomuoto)

patients <- levels(dialysis$potilas)

for (person_id in 1:length(patients)) {
#for (person_id in 1:37) {
  
  # - initial graph structure
  initial_graph <- mebn.fully_connected_bipartite_graph(dialysis_datadesc)
  
  # - pick the estimated latent variables for all the persons
  local_distributions <- target_variables
  local_distributions$modelcache <- latent_parameter_modeldir
  
  # - get personal data, normalized and original
  
  # - statistics for the nutrition levels are calculated from normalized data (as it was in the likelihood estimation)
  predictors <- nrow(dialysis_predictors)
  normalized_input <- sapply(1:predictors, mebn.scale_gaussians, data = dialysis, datadesc = dialysis_predictors, log_transform_ln = FALSE)
  normalized_input_df <- as.data.frame(normalized_input)
  
  # - pick rows for the selected person
  subject_code <- levels(dialysis$potilas)[person_id]
  personal_data_df <- cbind(dialysis$potilas, normalized_input_df)
  personal_data_df <- personal_data_df[personal_data_df$`dialysis$potilas` == subject_code,]
  personal_data <- as.matrix(subset(personal_data_df, select = -c(`dialysis$potilas`)))
  
  # - store also these original stats in graph
  personal_data_org <- subset(dialysis[dialysis$potilas == subject_code,], select = as.vector(dialysis_predictors$Name))
  personal_concentrations_org <- subset(dialysis[dialysis$potilas == subject_code,], select = as.vector(dialysis_targets$Name))
  
  personal_model_dir <- paste0(graph_dir, person_id)
  
  # Generate a personal graph in directory
  
  group_id <- as.numeric(unique(dialysis[dialysis$potilas == subject_code,]$hoitoryhma))

  # one-level, univariate models
  #personal_graph <- mebn.extract_personal_graph(person_id, initial_graph, personal_model_dir, assumedpredictors, target_variables, latent_parameter_modeldir, personal_data, personal_data_org)

  # one-level model
  #personal_graph <- mebn.extract_personal_graph_from_mv(person_id, initial_graph, personal_model_dir, assumedpredictors, assumedtargets, latent_parameter_modeldir, personal_data, personal_data_org, personal_concentrations_org, datadesc)

  # two-level model
  personal_graph <- mebn.extract_multilevel_graph(person_id, group_id, initial_graph, personal_model_dir, dialysis_predictors, dialysis_targets, latent_parameter_modeldir, personal_data, personal_data_org, personal_concentrations_org, dialysis_datadesc)
  
}

```

```{r check_failed_concs}
library(igraph)

check_failed_concs <- function(graph_person_id, personal_info, recommeded_concentrations) {
  
  pk_min <- recommeded_concentrations$lower_limits[1]
  fppi_min <- recommeded_concentrations$lower_limits[2]
  palb_min <- recommeded_concentrations$lower_limits[3]
  pk_max <- recommeded_concentrations$upper_limits[1]
  fppi_max <- recommeded_concentrations$upper_limits[2]
  palb_max <- recommeded_concentrations$upper_limits[3]

  graph_dir <- paste0("graphs/dialysis/mv3_cross_two_levels/",graph_person_id)
  personal_graph <- read.graph(paste0(graph_dir, "/personal_graph.graphml"), "graphml")
  
  current_pk <- V(personal_graph)["pk"]$value_mean
  current_fppi <- V(personal_graph)["fppi"]$value_mean
  current_palb <- V(personal_graph)["palb"]$value_mean

  is_failing <- current_pk < pk_min | current_pk > pk_max |
    current_fppi < fppi_min | current_fppi > fppi_max |
    current_palb < palb_min | current_palb > palb_max

  return(is_failing)
}

for (graph_person_id in 1:37) {

  subject_code <- levels(dialysis$potilas)[graph_person_id]
  treatment <- unique(dialysis[dialysis$potilas == subject_code,]$hoitomuoto)
  
  # Normal ranges of concentration are personalized
  personal_info <- head(dialysis[dialysis$potilas == subject_code,],1)
  recommeded_concentrations <- mebn.get_personal_dialysis_guidelines(personal_info, patient_in_dialysis = TRUE)
  
  if (check_failed_concs(graph_person_id, personal_info, recommeded_concentrations) == TRUE) { 
    print(subject_code)
    print(graph_person_id)
  }
}
    

```

```{r recommendation_with_custom_utility_org_scale, eval=FALSE,echo=FALSE, message=FALSE}
source("mebn/v3/MEBNv3.r")
library(igraph) 
library(dplyr)
library(ggplot2)
library(gridExtra)
  
# Query parameters
simulation <- "X50_B50_A50_I50"

# - data parameters
graph_dir <- "graphs/dialysis/mv3_cross_two_levels/"

datadesc <- dialysis_datadesc

assumedpredictors <- dialysis_predictors
assumedtargets <- dialysis_targets

# Calculate statistics for normalizing the data

org_stats <- data.frame(name = subset(assumedpredictors$Name, assumedpredictors$Distribution == "Gaussian"))
org_stats$mean <- sapply(org_stats$name, function(x) mean(dialysis[[x]]))
org_stats$sd <- sapply(org_stats$name, function(x) sd(dialysis[[x]]))

queried_nodes <- as.vector(datadesc[datadesc$Condition >= 100,]$Name)

# intake bounds and RI are normalized to dialysis dataset
lowerbounds <- sapply(queried_nodes, function(x) (as.numeric(datadesc[datadesc$Name==x,]$Lowerbound) - org_stats[org_stats$name == x,]$mean) / org_stats[org_stats$name == x,]$sd)
upperbounds <- sapply(queried_nodes, function(x) (as.numeric(datadesc[datadesc$Name==x,]$Upperbound) - org_stats[org_stats$name == x,]$mean) / org_stats[org_stats$name == x,]$sd)

# generally recommended intake (RI)
RI <- sapply(queried_nodes, function(x) (as.numeric(datadesc[datadesc$Name==x,]$Recommendation) - org_stats[org_stats$name == x,]$mean) / org_stats[org_stats$name == x,]$sd)

# - collect personal statistics in this data frame
patient_summary <- data.frame(matrix(ncol = 3 + length(queried_nodes) * 3 + nrow(assumedtargets) * 3, nrow = 0), row.names = NULL)

colnames(patient_summary) <- c("person_id", "subject_code", "accepted", paste0(queried_nodes), paste0(queried_nodes, "_lCI"), paste0(queried_nodes, "_uCI"), assumedtargets$Name, paste0(assumedtargets$Name, "_lCI"), paste0(assumedtargets$Name, "_uCI"))

for (graph_person_id in 1:37) {

  subject_code <- levels(dialysis$potilas)[graph_person_id]
  treatment <- unique(dialysis[dialysis$potilas == subject_code,]$hoitomuoto)
  
  # Normal ranges of concentration are personalized
  personal_info <- head(dialysis[dialysis$potilas == subject_code,],1)
  recommeded_concentrations <- mebn.get_personal_dialysis_guidelines(personal_info, patient_in_dialysis = TRUE)
  
  if (check_failed_concs(graph_person_id, personal_info, recommeded_concentrations) == TRUE) { 
  
      print(paste0("Simulating patient id ", graph_person_id))
      print(paste0("Simulating subject_code ", subject_code))
  
      personal_model_dir <- paste0(graph_dir,graph_person_id)
      personal_graph <- read.graph(paste0(personal_model_dir, "/personal_graph.graphml"), "graphml")  

      # Sample diet proposals and matching concentration predictions
      
      l3 <- 30
      l5 <- 2
      
      # - more loose preference for special cases
      if (graph_person_id == 1)
      {
         l3 <- 1
         l5 <- 1.0
      } else if (graph_person_id == 6)
      {
         l3 <- 27
         l5 <- 2
      }

      intake_model <- mebn.Query(reaction_graph = personal_graph,
                               graph_dir = personal_model_dir,
                               queried_nodes = queried_nodes,
                               query = recommeded_concentrations,
                               proposal_lowerlimits = lowerbounds,
                               proposal_upperlimits = upperbounds,
                               general_RI = RI,
                               stan_model_file = "diet/recommendation_model.stan",
                               conc_lower_limits = as.vector(recommeded_concentrations$lower_limits),
                               conc_upper_limits = as.vector(recommeded_concentrations$upper_limits),
                               beta_point_est = "mean",
                               param_point_est = "mean",
                               X_point_est = "mean",
                               posterior_samples = 500,
                               repeat_only = 0,
                                   verbose = 1,
                                   l1 = 8,
                                   l2 = 15,
                                   l3 = l3,
                                   l4 = 30,
                                   l5 = l5,
                                   l6 = 10)
      
      # Function to calculate baseline-adjusted normalized effects
      calculate_adjusted_effect <- function(beta_norm, mean_val, sd_val) {
        baseline_adj_norm <- -(beta_norm * mean_val) / (sd_val^2)
        beta_adj <- beta_norm + baseline_adj_norm
        return(list(beta_adj = beta_adj, baseline_adj_norm = baseline_adj_norm))
      }
      
      # Extract all the samples and correlate concentrations and intake with proposal IDs
      result <- rstan::extract(intake_model)
      
      # Add inference details
      intake_proposals.df <- data.frame(proposal = 1:dim(result$Y_mu)[1])
      intake_proposals.df$lp <- result$lp__
      intake_proposals.df$preference <- result$preference_lpdf
      intake_proposals.df$limitsum <- result$softlimit_sum
      
      # Data frames for storing baseline-adjusted effects in normalized scale and contributions in original scale
      effects.df <- data.frame()
      contributions.df <- data.frame()
      
      # Add expected values of concentrations
      for (target_index in 1:nrow(assumedtargets)) {
        target_name <- assumedtargets[target_index,]$Name
        conc_mu_distribution <- result$Y_mu[, target_index]
        intake_proposals.df <- cbind(intake_proposals.df, conc_mu_distribution)
      
        # Data frames to temporarily store effects and contributions
        temp_effect.df <- data.frame(queried_nodes)
        temp_effect.df$concentration <- target_name
      
        temp_contr.df <- data.frame(queried_nodes)
        temp_contr.df$concentration <- target_name
      
        # Arrays to store baseline-adjusted effects in normalized scale and contributions in original scale
        effects_adj <- c()
        effects_adj_lCI <- c()
        effects_adj_uCI <- c()
        
        contributions_org <- c()
        contributions_org_lCI <- c()
        contributions_org_uCI <- c()
        
        # Loop over each nutrient to calculate baseline-adjusted effects and contributions
        for (nutrient_index in 1:length(queried_nodes)) {
          nutrient_name <- queried_nodes[[nutrient_index]]
          effect_name <- paste0("personal_", nutrient_name, "_", target_name)
      
          # Extract personal beta estimates in normalized scale and their CIs
          beta_values <- c(V(personal_graph)[effect_name]$value, V(personal_graph)[effect_name]$value_lCI, V(personal_graph)[effect_name]$value_uCI)
          names(beta_values) <- c("beta", "beta_lCI", "beta_uCI")
      
          # Calculate adjusted normalized effects for each CI level
          adjusted_results <- lapply(beta_values, calculate_adjusted_effect, mean_val = org_stats$mean[nutrient_index], sd_val = org_stats$sd[nutrient_index])
          
          # Extract adjusted effects
          beta_adj <- adjusted_results$beta$beta_adj
          beta_adj_lCI <- adjusted_results$beta_lCI$beta_adj
          beta_adj_uCI <- adjusted_results$beta_uCI$beta_adj
      
          effects_adj <- c(effects_adj, beta_adj)
          effects_adj_lCI <- c(effects_adj_lCI, beta_adj_lCI)
          effects_adj_uCI <- c(effects_adj_uCI, beta_adj_uCI)
      
          # Contribution using recommended intake
          Q_proposal <- result$Q[, nutrient_index] * org_stats$sd[nutrient_index] + org_stats$mean[nutrient_index]
          intake_org <- mean(Q_proposal)
      
          personal_beta_org <- beta_values["beta"] / org_stats$sd[nutrient_index]
          personal_beta_org_lCI <- beta_values["beta_lCI"] / org_stats$sd[nutrient_index]
          personal_beta_org_uCI <- beta_values["beta_uCI"] / org_stats$sd[nutrient_index]
      
          baseline_adj <- -(beta_values["beta"] * org_stats$mean[nutrient_index]) / org_stats$sd[nutrient_index]
          baseline_adj_lCI <- -(beta_values["beta_lCI"] * org_stats$mean[nutrient_index]) / org_stats$sd[nutrient_index]
          baseline_adj_uCI <- -(beta_values["beta_uCI"] * org_stats$mean[nutrient_index]) / org_stats$sd[nutrient_index]
      
          contribution_org <- personal_beta_org * intake_org + baseline_adj
          contribution_org_lCI <- personal_beta_org_lCI * intake_org + baseline_adj_lCI
          contribution_org_uCI <- personal_beta_org_uCI * intake_org + baseline_adj_uCI
      
          contributions_org <- c(contributions_org, contribution_org)
          contributions_org_lCI <- c(contributions_org_lCI, contribution_org_lCI)
          contributions_org_uCI <- c(contributions_org_uCI, contribution_org_uCI)
        }
      
        # Store results for effects
        temp_effect.df$effects <- effects_adj
        temp_effect.df$effects_lCI <- effects_adj_lCI
        temp_effect.df$effects_uCI <- effects_adj_uCI
        effects.df <- rbind(effects.df, temp_effect.df)
      
        # Store results for contributions
        temp_contr.df$contributions <- contributions_org
        temp_contr.df$contributions_lCI <- contributions_org_lCI
        temp_contr.df$contributions_uCI <- contributions_org_uCI
        
        # Adding the baseline concentration level
        baselevel <- head(result$Y_mu_Q0[, target_index], 1)
        temp_contr.df <- rbind(temp_contr.df, c("base", target_name, baselevel, baselevel, baselevel))
      
        contributions.df <- rbind(contributions.df, temp_contr.df)
      }
      
      # Save the results
      saveRDS(effects.df, paste0("patient_summary/dialysis/mv3_cross_two_levels/simulation", simulation, "/details/effects_", graph_person_id, ".rds"))
      saveRDS(contributions.df, paste0("patient_summary/dialysis/mv3_cross_two_levels/simulation", simulation, "/details/contributions_", graph_person_id, ".rds"))
      
      # Add related intake proposals
      for (nutrient_index in 1:length(queried_nodes)) {
        node_name <- queried_nodes[[nutrient_index]]
        Q_proposal <- result$Q[,nutrient_index] * org_stats[org_stats$name == node_name,]$sd + org_stats[org_stats$name == node_name,]$mean
        intake_proposals.df <- cbind(intake_proposals.df, Q_proposal)
      }
      
      colnames(intake_proposals.df) <- c("proposal", "lp", "preference", "limitsum", assumedtargets$Name, queried_nodes)
      
      saveRDS(intake_proposals.df %>% as.data.frame(), paste0("patient_summary/dialysis/mv3_cross_two_levels/simulation",simulation,"/details/accepted_intake_",graph_person_id,".rds"))
    
      # Filter recommendation distributions
      recommendation_intake.df <- intake_proposals.df %>%
        filter(limitsum >= 2 * nrow(assumedtargets) - 0.5) %>%
        as.data.frame()
    
      saveRDS(recommendation_intake.df %>% as.data.frame(), paste0("patient_summary/dialysis/mv3_cross_two_levels/simulation",simulation,"/details/recommendation_intake_",graph_person_id,".rds"))
          
      print(paste0("Number of recommendation sample size ", nrow(recommendation_intake.df)))
      
      if (nrow(recommendation_intake.df) > 0)
      {
          RI_mean <- colMeans(recommendation_intake.df[queried_nodes])
          RI_quantiles <- lapply(recommendation_intake.df[queried_nodes], quantile, probs = c(0.025,0.975))
          RI_lower_quantiles <- as.vector(unlist(RI_quantiles)[seq(1, length(queried_nodes)*2, by = 2)])
          RI_upper_quantiles <- as.vector(unlist(RI_quantiles)[seq(2, length(queried_nodes)*2, by = 2)])
          
          personal_intake <- c(graph_person_id,
                               subject_code,
                               1,
                               RI_mean,
                               RI_lower_quantiles,
                               RI_upper_quantiles,
                               mean(recommendation_intake.df$pk),
                               mean(recommendation_intake.df$fppi),
                               mean(recommendation_intake.df$palb),
                               colMeans(result$Y_limit[,seq(1, nrow(assumedtargets))]),
                               colMeans(result$Y_limit[,2*seq(1, nrow(assumedtargets))])
                               )
      } 
      else
      {
         personal_intake <- c(graph_person_id,
                              subject_code,
                              0,
                              rep(0,length(queried_nodes) * 3),
                              mean(recommendation_intake.df$pk),
                              mean(recommendation_intake.df$fppi),
                              mean(recommendation_intake.df$palb),
                              colMeans(result$Y_limit[,seq(1, nrow(assumedtargets))]),
                              colMeans(result$Y_limit[,2*seq(1, nrow(assumedtargets))])
                              )
      }
    
      patient_summary <- rbind(patient_summary, personal_intake)
  }
}

colnames(patient_summary) <- c("person_id", "subject_code", "accepted", paste0(queried_nodes), paste0(queried_nodes, "_lCI"), paste0(queried_nodes, "_uCI"), assumedtargets$Name, paste0(assumedtargets$Name, "_lowerbound"), paste0(assumedtargets$Name, "_upperbound"))

saveRDS(patient_summary, paste0("patient_summary/dialysis/mv3_cross_two_levels/simulation",simulation,"/recommendation_summary.rds"))

# As a result, we have proposal distributions of nutrients. Next, 
```


```{r fig.height=6, inference_debug}

pk_recommendations <- c(recommeded_concentrations$lower_limits[1], recommeded_concentrations$upper_limits[1])
fppi_recommendations <- c(recommeded_concentrations$lower_limits[2], recommeded_concentrations$upper_limits[2])
palb_recommendations <- c(recommeded_concentrations$lower_limits[3], recommeded_concentrations$upper_limits[3])

recommendation_intake.df <- intake_proposals.df 
#  filter(boundsum >= 2 * nrow(assumedtargets) - 3) %>%
#  as.data.frame()

conc_plot1 <- ggplot(recommendation_intake.df) +
  geom_point(aes(y=lp, x=pk, color=preference), show.legend=TRUE) +
  geom_vline(xintercept = pk_recommendations, linetype="solid", color = "black", linewidth=0.4) +
  scale_color_gradientn(colours = colorspace::diverge_hcl(7))

conc_plot2 <- ggplot(recommendation_intake.df) +
  geom_point(aes(y=lp, x=fppi, color=preference), show.legend=TRUE) +
  geom_vline(xintercept = fppi_recommendations, linetype="solid", color = "black", linewidth=0.4) +
  scale_color_gradientn(colours = colorspace::diverge_hcl(7))

conc_plot3 <- ggplot(recommendation_intake.df) +
  geom_point(aes(y=lp, x=palb, color=preference), show.legend=TRUE) +
  geom_vline(xintercept = palb_recommendations, linetype="solid", color = "black", linewidth=0.4) +
  scale_color_gradientn(colours = colorspace::diverge_hcl(7))

lay <- rbind(c(1),
             c(2),
             c(3))

lp_plot <- grid.arrange(conc_plot1, conc_plot2, conc_plot3, layout_matrix = lay, padding=0)
  
```

```{r current_levels}
# Add current levels of intake and concentrations to the data frame
library(stringr)
library(igraph)

datadesc <- dialysis_datadesc

queried_nodes <- as.vector(datadesc[datadesc$Condition >= 100,]$Name)

recommendation_with_concpreds.df <- readRDS("patient_summary/dialysis/mv3_cross_two_levels/simulationX50_B50_A50_I50/recommendation_summary.rds")

current_diet.df <- data.frame(matrix(ncol = 1 + length(queried_nodes) + nrow(dialysis_targets), nrow = 0), row.names = NULL)
personal_effects <- data.frame()

for (subject_code in recommendation_with_concpreds.df$subject_code) {
  
  graph_person_id <- match(subject_code, levels(dialysis$potilas))

  graph_dir <- paste0("graphs/dialysis/mv3_cross_two_levels/",graph_person_id)
  personal_graph <- read.graph(paste0(graph_dir, "/personal_graph.graphml"), "graphml")
  nodes <- V(personal_graph)
  
  # Current intake levels
  
  current_intake <- c()
  intake_nodes <- V(personal_graph)[queried_nodes]
  
  for (i in 1:length(queried_nodes))
  {
    current_dist <- intake_nodes[i]$distribution
    
    current_intake_level <- 0
    if (startsWith(current_dist, "N"))
    {
        # get current intake from mean of intake normal distribution
        current_intake_level <- as.numeric(str_extract(current_dist, "(?<=N\\().+(?=,)")) # N(*,
    }
  
    current_intake <- c(current_intake, current_intake_level)
    
    # collect personal effects statistics
    for (t in dialysis_targets$Name)
    {
        effects.df <- readRDS(paste0("patient_summary/dialysis/mv3_cross_two_levels/simulationX50_B50_A50_I50/details/effects_",graph_person_id,".rds"))

        effect_name <- paste0(queried_nodes[i],"_",t)
        
        beta_adj <- effects.df[effects.df$queried_nodes == queried_nodes[i] & effects.df$concentration == t,]$effects
        beta_adj_lCI <- effects.df[effects.df$queried_nodes == queried_nodes[i] & effects.df$concentration == t,]$effects_lCI
        beta_adj_uCI <- effects.df[effects.df$queried_nodes == queried_nodes[i] & effects.df$concentration == t,]$effects_uCI

        effects_org <-  c(graph_person_id,
                          effect_name,
                          beta_adj,
                          beta_adj_lCI,
                          beta_adj_uCI)

        personal_effects <- rbind(personal_effects, effects_org)
    }
  }
  
  # Current concentration levels

  current_concs <- c()
  conc_nodes <- V(personal_graph)[dialysis_targets$Name]
  
  for (i in 1:length(conc_nodes))
  {
    current_conc_level <- conc_nodes[i]$value_mean
    current_concs <- c(current_concs, current_conc_level)
  }
  
  current_diet.df <- rbind(current_diet.df, c(as.character(graph_person_id), current_intake, current_concs))
}

colnames(personal_effects) <- c("graph_person_id", "effect", "value", "value_lCI", "value_uCI")

colnames(current_diet.df) <- c("person_id", paste0("current_", queried_nodes), paste0("current_", dialysis_targets$Name))

# Join recommendations with current situation
recommendation_with_concpreds.df$person_id <- as.integer(recommendation_with_concpreds.df$person_id)
current_diet.df$person_id <- as.integer(current_diet.df$person_id)

recommendation_with_concpreds_and_current.df <- recommendation_with_concpreds.df %>% inner_join(current_diet.df, by="person_id")

# Convert all columns as numerics
recommendation_with_concpreds_and_current.df <- as.data.frame(sapply(recommendation_with_concpreds_and_current.df, as.numeric))

saveRDS(recommendation_with_concpreds_and_current.df, paste0("patient_summary/dialysis/mv3_cross_two_levels/simulationX50_B50_A50_I50/recommendation_summary_with_concpreds_and_current.rds"))

```

```{r}
library(kableExtra) # for HTML and Latex tables

# personal_effects is gathered in the previous block
effect_summary <- personal_effects %>% 
  group_by(effect) %>%
  dplyr::summarise(
                effect_avg = mean(as.numeric(value)),
                effect_sd = sd(as.numeric(value)),                 
                min_personal = min(as.numeric(value)),
                min_personal_lCI = as.numeric(value_lCI[which.min(as.numeric(value))]),
                min_personal_uCI = as.numeric(value_uCI[which.min(as.numeric(value))]),
                max_personal = max(as.numeric(value)),
                max_personal_lCI = as.numeric(value_lCI[which.max(as.numeric(value))]),
                max_personal_uCI = as.numeric(value_uCI[which.max(as.numeric(value))]),
                total_personal = abs(min_personal) + abs(max_personal)
  ) %>%
  arrange(desc(total_personal)) %>%
  top_n(20)

effect_summary_table.df <- data.frame(effect <- effect_summary$effect, row.names = NULL)

effect_summary_table.df$effect_avg <- linebreak(paste0(format(round(effect_summary$effect_avg,2), nsmall=2)))
effect_summary_table.df$effect_sd <- linebreak(paste0(format(round(effect_summary$effect_sd,2), nsmall=2)))

effect_summary_table.df$min_personal <- linebreak(paste0(format(round(effect_summary$min_personal,2), nsmall=2),"\n$\\left[",format(round(effect_summary$min_personal_lCI,2), nsmall=2),"; ",format(round(effect_summary$min_personal_uCI,2), nsmall=2),"\\right]$"), align = "c")

effect_summary_table.df$max_personal <- linebreak(paste0(format(round(effect_summary$max_personal,2), nsmall=2),"\n$\\left[",format(round(effect_summary$max_personal_lCI,2), nsmall=2),"; ",format(round(effect_summary$max_personal_uCI,2), nsmall=2),"\\right]$"), align = "c")

colnames(effect_summary_table.df) <- c("effect", "effect_avg", "effect_sd", "min_personal", "max_personal")

# lookup dataframe for pretty effect names
all_effects <- expand.grid(predictor = dialysis_predictors$Name, target = dialysis_targets$Name)
all_descs <- expand.grid(predictor = dialysis_predictors$ShortDescription, target = dialysis_targets$ShortDescription)
effect_desc.df <- data.frame(effect <- paste0(all_effects$predictor,"_",all_effects$target), row.names = NULL)
effect_desc.df$desc <- paste0(effect <- paste0(all_descs$predictor," -> ",all_descs$target))
effect_desc.df$nutrient <- all_descs$predictor
effect_desc.df$concentration <- all_descs$target
colnames(effect_desc.df) <- c("effect", "effect_description", "nutrient", "concentration")

effect_summary_table.df <- effect_summary_table.df %>% left_join(effect_desc.df, by = "effect")

kable(effect_summary_table.df[c(6,2:5)], "latex", escape = F, booktabs = T, row.names = FALSE, digits = 2,align="lcccc",
  col.names = c("Effect", "Avg. effect", "Effect sd.", "Min. personal effect", "Max personal effect")) %>%
  kable_styling(latex_options="scale_down") %>%
  kable_styling(latex_options = c("basic", "condensed"), full_width = TRUE) %>%
  row_spec(0,bold=TRUE) %>%
  save_kable(file = "tables/dialysis_effects.pdf", keep_tex = TRUE)

```

#dialysis_lp_plots

```{r dialysis_lp_plots-function}

dialysis_lp_plots <- function(subject_code_vector, plot_path) {

  library(ggplot2)
  library(gridExtra)
  
  ## TEST
  #dialysis_with_failed_concs <- subjects_with_failed_concs[1:7,]$subject_code
  #subject_code_vector <- dialysis_with_failed_concs
  ## TEST

  persons <- length(subject_code_vector)
  
  concinfo.df <- readRDS("patient_summary/dialysis/mv3_cross_two_levels/simulationX50_B50_A50_I50/recommendation_summary_with_concpreds_and_current.rds")
  
  simulation <- "X50_B50_A50_I50"
  conc_plots <- vector('list', persons)
  
  pk_scale_min <- min(3.4, concinfo.df$current_pk[1:persons])-0.1
  pk_scale_max <- max(4.7, concinfo.df$current_pk[1:persons])+0.1
  fppi_scale_min <- min(0.9, concinfo.df$current_fppi[1:persons])-0.1
  fppi_scale_max <- max(1.78, concinfo.df$current_fppi[1:persons])+0.1
  palb_scale_min <- min(34, concinfo.df$current_palb[1:persons])-0.5
  palb_scale_max <- max(45, concinfo.df$current_palb[1:persons])+0.5
  
  point_size <- 0.5
  
  gradient_colors <- colorspace::heat_hcl(3)
  plot_index <- 1
  
  for (subject_code in subject_code_vector[1:(persons-1)]) {
    
      graph_person_id <- match(subject_code, levels(dialysis$potilas))
      
      accepted_intake.df <- readRDS(paste0("patient_summary/dialysis/mv3_cross_two_levels/simulationX50_B50_A50_I50/details/accepted_intake_",graph_person_id,".rds"))
      
      print(graph_person_id)
  
      # Get personal normal ranges 
    
      personal_info <- head(dialysis[dialysis$potilas == subject_code,],1)
      recommeded_concentrations <- mebn.get_personal_dialysis_guidelines(personal_info, patient_in_dialysis = TRUE)
  
      pk_recommendations <- c(recommeded_concentrations$lower_limits[1], recommeded_concentrations$upper_limits[1])
      fppi_recommendations <- c(recommeded_concentrations$lower_limits[2], recommeded_concentrations$upper_limits[2])
      palb_recommendations <- c(recommeded_concentrations$lower_limits[3], recommeded_concentrations$upper_limits[3])
      
      # Get current personal info and predictions
    
      curr_pk <- concinfo.df[concinfo.df$subject_code == subject_code,]$current_pk
      curr_fppi <- concinfo.df[concinfo.df$subject_code == subject_code,]$current_fppi
      curr_palb <- concinfo.df[concinfo.df$subject_code == subject_code,]$current_palb
  
      pred_pk <- concinfo.df[concinfo.df$subject_code == subject_code,]$pk
      pred_fppi <- concinfo.df[concinfo.df$subject_code == subject_code,]$fppi
      pred_palb <- concinfo.df[concinfo.df$subject_code == subject_code,]$palb
      
      conc_plot1 <- ggplot(accepted_intake.df) +
        geom_point(aes(y=lp, x=pk, color=preference), size = point_size, show.legend = FALSE) +
        geom_vline(xintercept = pk_recommendations, linetype="solid", color = "darkgrey", linewidth=0.2) +
        geom_vline(xintercept = pred_pk, linetype="solid", color = "black", linewidth=0.3) +
        geom_vline(xintercept = curr_pk, linetype="dashed", color = "black", linewidth=0.3) +
        annotate("rect",ymin=-Inf, ymax=Inf, xmin=-Inf, xmax=pk_recommendations[1], alpha = .2) + 
        annotate("rect",ymin=-Inf, ymax=Inf, xmin=pk_recommendations[2], xmax=Inf, alpha = .2) + 
        scale_x_continuous(limits=c(pk_scale_min, pk_scale_max), breaks=pk_recommendations) +
        scale_color_gradientn(colours = colorspace::diverge_hcl(7)) +
        theme_bw() +
        scale_color_gradientn(colours = gradient_colors) +
        theme(panel.grid.minor = element_blank()) +
        labs(x = element_blank(), y = paste0(subject_code, " ", "\nlog-prob."))
  
      conc_plot2 <- ggplot(accepted_intake.df) +
        geom_point(aes(y=lp, x=fppi, color=preference), size = point_size, show.legend = FALSE) +
        geom_vline(xintercept = fppi_recommendations, linetype="solid", color = "darkgrey", linewidth=0.4) +
        geom_vline(xintercept = pred_fppi, linetype="solid", color = "black", linewidth=0.3) +
        geom_vline(xintercept = curr_fppi, linetype="dashed", color = "black", linewidth=0.3) +
        annotate("rect",ymin=-Inf, ymax=Inf, xmin=-Inf, xmax=fppi_recommendations[1], alpha = .2) + 
        annotate("rect",ymin=-Inf, ymax=Inf, xmin=fppi_recommendations[2], xmax=Inf, alpha = .2) + 
        scale_x_continuous(limits=c(fppi_scale_min, fppi_scale_max), breaks=fppi_recommendations) +
        scale_color_gradientn(colours = gradient_colors) +
        theme_bw() +
        theme(panel.grid.minor = element_blank()) +
        labs(x = element_blank(), y = element_blank())
      
      conc_plot3 <- ggplot(accepted_intake.df) +
        geom_point(aes(y=lp, x=palb, color=preference), size = point_size, show.legend = FALSE) +
        geom_vline(xintercept = palb_recommendations, linetype="solid", color = "darkgrey", linewidth=0.4) +
        geom_vline(xintercept = pred_palb, linetype="solid", color = "black", linewidth=0.3) +
        geom_vline(xintercept = curr_palb, linetype="dashed", color = "black", linewidth=0.3) +
        annotate("rect",ymin=-Inf, ymax=Inf, xmin=-Inf, xmax=palb_recommendations[1], alpha = .2) + 
        annotate("rect",ymin=-Inf, ymax=Inf, xmin=palb_recommendations[2], xmax=Inf, alpha = .2) + 
        scale_x_continuous(limits=c(palb_scale_min, palb_scale_max), breaks=c(34,36,45)) +
        scale_color_gradientn(colours = gradient_colors) +
        theme_bw() +
        theme(panel.grid.minor = element_blank()) +
        labs(x = element_blank(), y = element_blank())

      conc_plot <- grid.arrange(conc_plot1, conc_plot2, conc_plot3, ncol=3, padding=0, widths=c(1.1,1,1))
      
      conc_plots[[plot_index]] <- conc_plot
      plot_index <- plot_index + 1
  }
  
  subject_code <- subject_code_vector[[persons]]
  graph_person_id <- concinfo.df[concinfo.df$subject_code == subject_code,]$person_id
  
  accepted_intake.df <- readRDS(paste0("patient_summary/dialysis/mv3_cross_two_levels/simulation",simulation,"/details/accepted_intake_",graph_person_id,".rds"))
  
  # Get personal normal ranges 
  
  personal_info <- head(dialysis[dialysis$potilas == subject_code,],1)
  recommeded_concentrations <- mebn.get_personal_dialysis_guidelines(personal_info, patient_in_dialysis = TRUE)
  
  pk_recommendations <- c(recommeded_concentrations$lower_limits[1], recommeded_concentrations$upper_limits[1])
  fppi_recommendations <- c(recommeded_concentrations$lower_limits[2], recommeded_concentrations$upper_limits[2])
  palb_recommendations <- c(recommeded_concentrations$lower_limits[3], recommeded_concentrations$upper_limits[3])
      
  conc_plot1 <- ggplot(accepted_intake.df) +
    geom_point(aes(y=lp, x=pk, color=preference), size = point_size, show.legend = FALSE) +
    geom_vline(xintercept = pk_recommendations, linetype="solid", color = "darkgrey", linewidth=0.4) +
    geom_vline(xintercept = pred_pk, linetype="solid", color = "black", linewidth=0.3) +
    geom_vline(xintercept = curr_pk, linetype="dashed", color = "black", linewidth=0.3) +
    annotate("rect",ymin=-Inf, ymax=Inf, xmin=-Inf, xmax=pk_recommendations[1], alpha = .2) + 
    annotate("rect",ymin=-Inf, ymax=Inf, xmin=pk_recommendations[2], xmax=Inf, alpha = .2) + 
    scale_x_continuous(limits=c(pk_scale_min, pk_scale_max), breaks=pk_recommendations) + 
    scale_color_gradientn(colours = gradient_colors) +
    theme_bw() +
    theme(panel.grid.minor = element_blank()) +
    labs(x = "P-K (mmol/l)", y = paste0(subject_code, " ", "\nlog-prob."))

  conc_plot2 <- ggplot(accepted_intake.df) +
    geom_point(aes(y=lp, x=fppi, color=preference), size = point_size, show.legend = FALSE) +
    geom_vline(xintercept = fppi_recommendations, linetype="solid", color = "darkgrey", linewidth=0.4) +
    geom_vline(xintercept = pred_fppi, linetype="solid", color = "black", linewidth=0.3) +
    geom_vline(xintercept = curr_fppi, linetype="dashed", color = "black", linewidth=0.3) +
    annotate("rect",ymin=-Inf, ymax=Inf, xmin=-Inf, xmax=fppi_recommendations[1], alpha = .2) + 
    annotate("rect",ymin=-Inf, ymax=Inf, xmin=fppi_recommendations[2], xmax=Inf, alpha = .2) + 
    scale_x_continuous(limits=c(fppi_scale_min, fppi_scale_max), breaks=fppi_recommendations) +
    scale_color_gradientn(colours = gradient_colors) +
    theme_bw() +
    theme(panel.grid.minor = element_blank()) +
    labs(x = "fP-Pi (mmol/l)", y = element_blank())
  
  conc_plot3 <- ggplot(accepted_intake.df) +
    geom_point(aes(y=lp, x=palb, color=preference), size = point_size, show.legend = FALSE) +
    geom_vline(xintercept = palb_recommendations, linetype="solid", color = "darkgrey", linewidth=0.4) +
    geom_vline(xintercept = pred_palb, linetype="solid", color = "black", linewidth=0.3) +
    geom_vline(xintercept = curr_palb, linetype="dashed", color = "black", linewidth=0.3) +
    annotate("rect",ymin=-Inf, ymax=Inf, xmin=-Inf, xmax=palb_recommendations[1], alpha = .2) + 
    annotate("rect",ymin=-Inf, ymax=Inf, xmin=palb_recommendations[2], xmax=Inf, alpha = .2) + 
    scale_x_continuous(limits=c(palb_scale_min, palb_scale_max), breaks=c(34,36,45)) +
    scale_color_gradientn(colours = gradient_colors) +
    theme_bw() +
    theme(panel.grid.minor = element_blank()) +
    labs(x = "P-Alb (mmol/l)", y = element_blank())
  
  conc_plot <- grid.arrange(conc_plot1, conc_plot2, conc_plot3, ncol=3, padding=0, widths=c(1.1,1,1))
    
  conc_plots[[plot_index]] <- conc_plot

  full_conc_plot <- grid.arrange(grobs = conc_plots, ncol=1, padding=0, heights=c(rep(1, persons-1),1.15))
  
  ggsave(plot_path, plot = full_conc_plot)
  
}

```

#dialysis_lp_article_plot
```{r dialysis_lp_article_plot, cache=FALSE, eval=TRUE, echo=FALSE,message=FALSE, warning=FALSE, fig.width=7, fig.height=10, fig.keep='last'}

subjects_with_failed_concs <- readRDS("patient_summary/dialysis/mv3_cross_two_levels/simulationX50_B50_A50_I50/recommendation_summary_with_concpreds_and_current.rds")

# plot just 10 of 32 that have failed concs
dialysis_with_failed_concs <- subjects_with_failed_concs[1:10,]

dialysis_lp_plots(dialysis_with_failed_concs$subject_code, "figures/dialysis_fixed_concentrations.pdf")

```
# Intake recommendation

```{r diet_recommendations_with_change}
# Visualize the main results
library(dplyr)
library(tibble)
library(tidyr)
library(kableExtra)

intake.df <- readRDS("patient_summary/dialysis/mv3_cross_two_levels/simulationX50_B50_A50_I50/recommendation_summary_with_concpreds_and_current.rds")

recommendation <- colnames(intake.df)[4:(4+12)]

cond_nutrients <- dialysis_predictors[dialysis_predictors$Condition >= 100,]
table_colnames <- c("", cond_nutrients$ShortDescription)

up_color <- "#C23B22"
down_color <- "#00BFC4"
down_color <- "#3A5874"
keep_color <- "#000000"

recommendation_table.df <- intake.df %>%
                              # Recommendation cell coloring conditional on difference from current value
                              mutate(across(.cols = all_of(recommendation),
                                            .fns = ~case_when(
                                               get(glue::glue("current_{cur_column()}")) < .x ~ up_color,
                                               get(glue::glue("current_{cur_column()}")) > .x ~ down_color,
                                               get(glue::glue("current_{cur_column()}")) == .x ~ keep_color,
                                            ),
                                            .names = "{.col}_color")) %>%
                              # Cell bolding conditional on amount of the difference (30%)
                              mutate(across(.cols = all_of(recommendation),
                                            .fns = ~case_when(
                                               abs((get(glue::glue("current_{cur_column()}")) - .x) / .x * 100) > 30 ~ TRUE,
                                               abs((get(glue::glue("current_{cur_column()}")) - .x) / .x * 100) < 30 ~ FALSE,
                                            ),
                                            .names = "{.col}_bold")) %>%
                              # Round, format and paste as multiline-string with CI
                              mutate(across(.cols = all_of(recommendation),
                                            .fns = ~linebreak(paste0(
                                              "${_{",
                                              format(round(get(glue::glue("current_{cur_column()}")), cond_nutrients[cond_nutrients$Name == {cur_column()},]$Decimals), 
                                                     nsmall = cond_nutrients[cond_nutrients$Name == {cur_column()},]$Decimals),
                                              "\\rightarrow}}$ \n",
                                              format(round(.x, cond_nutrients[cond_nutrients$Name == {cur_column()},]$Decimals), 
                                                     nsmall = cond_nutrients[cond_nutrients$Name == {cur_column()},]$Decimals),
                                              "\n${^{\\left[",
                                              format(round(get(glue::glue("{cur_column()}_lCI")), cond_nutrients[cond_nutrients$Name == {cur_column()},]$Decimals), 
                                                     nsmall = cond_nutrients[cond_nutrients$Name == {cur_column()},]$Decimals),
                                              "; ", 
                                              format(round(get(glue::glue("{cur_column()}_uCI")), cond_nutrients[cond_nutrients$Name == {cur_column()},]$Decimals), 
                                                    nsmall = cond_nutrients[cond_nutrients$Name == {cur_column()},]$Decimals), 
                                              "\\right]}}$"), 
                                              align="c"),
                                            .names = "{.col}")) %>%
                              select(c("subject_code", recommendation, paste0(recommendation,"_color"), paste0(recommendation,"_bold")))

# Render PDF table and keep .tex

kable(recommendation_table.df[1:14], format = "latex", escape = F, booktabs = T, row.names = FALSE, align = c("r", rep("c",13)), 
   col.names = table_colnames,
   caption = "Personally recommended intake (RI) for renal patients with lower and upper limits of recommendations.") %>%
    kable_styling(latex_options="scale_down") %>%  
    kable_styling(latex_options = c("basic", "condensed"), full_width = TRUE) %>%
   row_spec(0,bold=TRUE) %>%
   column_spec(1, color = "#000000") %>%
   column_spec(2, color = recommendation_table.df[,15], bold = recommendation_table.df[,28], underline = recommendation_table.df[,15] == FALSE) %>%
   column_spec(3, color = recommendation_table.df[,16], bold = recommendation_table.df[,29], underline = recommendation_table.df[,16] == FALSE) %>%
   column_spec(4, color = recommendation_table.df[,17], bold = recommendation_table.df[,30], underline = recommendation_table.df[,17] == FALSE) %>%
   column_spec(5, color = recommendation_table.df[,18], bold = recommendation_table.df[,31], underline = recommendation_table.df[,18] == FALSE) %>%
   column_spec(6, color = recommendation_table.df[,19], bold = recommendation_table.df[,32], underline = recommendation_table.df[,19] == FALSE) %>%
   column_spec(7, color = recommendation_table.df[,20], bold = recommendation_table.df[,33], underline = recommendation_table.df[,20] == FALSE) %>%
   column_spec(8, color = recommendation_table.df[,21], bold = recommendation_table.df[,34], underline = recommendation_table.df[,21] == FALSE) %>%
   column_spec(9, color = recommendation_table.df[,22], bold = recommendation_table.df[,35], underline = recommendation_table.df[,22] == FALSE) %>%
   column_spec(10, color = recommendation_table.df[,23], bold = recommendation_table.df[,36], underline = recommendation_table.df[,23] == FALSE) %>%
   column_spec(11, color = recommendation_table.df[,24], bold = recommendation_table.df[,37], underline = recommendation_table.df[,24] == FALSE) %>%
   column_spec(12, color = recommendation_table.df[,25], bold = recommendation_table.df[,38], underline = recommendation_table.df[,25] == FALSE) %>%
   column_spec(13, color = recommendation_table.df[,26], bold = recommendation_table.df[,39], underline = recommendation_table.df[,26] == FALSE) %>%
   column_spec(14, color = recommendation_table.df[,27], bold = recommendation_table.df[,40], underline = recommendation_table.df[,27] == FALSE) %>%
   save_kable(file = "tables/recommendations_dialysis_change.pdf", keep_tex = TRUE)

```

```{r diet_strategies_plot, fig.width=7}
library(dplyr)
library(ggplot2)

all_contributions.df <- data.frame()

for (person_id in 1:37)
{
  contr_file <- paste0("patient_summary/dialysis/mv3_cross_two_levels/simulationX50_B50_A50_I50/details/contributions_",person_id,".rds")

  if (file.exists(contr_file)) {
    contributions.df <- readRDS(contr_file)
    
    # contributions.df file contain also CIs but we visualize now just the expected value
    contributions.df <- contributions.df[c('queried_nodes','concentration','contributions')]
    
    all_contributions.df <- rbind(all_contributions.df, cbind(person_id, contributions.df))
  }
}

colnames(all_contributions.df) <- c("person_id", "nutrient", "concentration", "contributions")

# Calculate mean contributions of nutrients for sorting them

mean_contributions <- all_contributions.df %>%
  filter(nutrient != 'base') %>%
  group_by(nutrient) %>%
  summarise(mean_abs_contribution = mean(abs(as.numeric(contributions)), na.rm = TRUE)) %>%
  ungroup() %>%
  select(nutrient, mean_abs_contribution) 

mean_contributions <- mean_contributions %>%  left_join(dialysis_predictors, by = join_by(nutrient == Name)) 

# Join the mean_abs_contribution column to main data frame for sorting
df <- all_contributions.df %>%
  left_join(mean_contributions, by = "nutrient") 

# Baselevel of concentration is always sorted first
df[df$nutrient == "base",]$mean_abs_contribution <- 100

# Calculate the cumulative concentrations 
cumulative_concs <- df %>% 
     group_by(person_id, concentration) %>%
     arrange(desc(abs(mean_abs_contribution))) %>%
     mutate(predicted_concentration = cumsum(contributions)) %>%
     arrange((abs(mean_abs_contribution))) %>%
     mutate(nutrient=factor(nutrient, levels=nutrient)) %>%
     mutate(person_id=factor(person_id))


# Add subject codes for plotting and personal limits
limit_data <- data.frame()

for (person_id in as.numeric(levels(cumulative_concs$person_id)))
{
    subject_code <- levels(dialysis$potilas)[person_id]
    treatment <- unique(dialysis[dialysis$potilas == subject_code,]$hoitomuoto)
  
    # Normal ranges of concentration are personalized
    personal_info <- head(dialysis[dialysis$potilas == subject_code,],1)
    recommeded_concentrations <- mebn.get_personal_dialysis_guidelines(personal_info, patient_in_dialysis = TRUE)
  
    l.df <- data.frame(concentration = dialysis_targets$Name, lower_limits = as.vector(recommeded_concentrations$lower_limits), upper_limits = as.vector(recommeded_concentrations$upper_limits))
  
  limit_data <- rbind(limit_data, l.df)
}

limit_data <- unique(limit_data)

nutrient_labels <- setNames(cumulative_concs$ShortDescription, cumulative_concs$nutrient)
nutrient_labels <- paste0("+ ", nutrient_labels[!duplicated(names(nutrient_labels))])
nutrient_labels[14] <- "Baseline"

conc_labels <- c(pk = "P-K (mmol/l)", fppi = "fP-Pi (mmol/l)", palb = "P-Alb (mmol/l)")

p <- ggplot(cumulative_concs) +
   geom_point(aes(x = predicted_concentration, y = nutrient, color = person_id), size = 0.7, show.legend = FALSE) +
   geom_path(aes(x = predicted_concentration, y = nutrient, group = person_id, color = person_id), linewidth=0.3, show.legend = FALSE) +
   geom_vline(data = limit_data, aes(xintercept = upper_limits), linetype = "dashed", color = "#444444") +
   geom_vline(data = limit_data, aes(xintercept = lower_limits), linetype = "dashed", color = "#444444") +
   facet_wrap(~concentration,scales = "free_x", labeller = labeller(concentration = conc_labels)) +
   scale_y_discrete(labels = nutrient_labels) + 
   theme_bw() +
   labs(x = element_blank(), y = element_blank(), color="Subject") 
 p

ggsave("figures/dialysis_diet_strategies.pdf", plot = p)
  
```

```{r diet_strategies_table}
library(dplyr)
library(tidyr)
library(purrr)
library(kableExtra)

# Get unique concentrations
concentrations <- unique(cumulative_concs$concentration)

# Loop through each concentration and create summary statistics
summary_dfs <- lapply(concentrations, function(conc) {
  cumulative_concs %>%
  ungroup() %>%
    select(nutrient, concentration, contributions) %>%
    filter(concentration == conc) %>%
    filter(nutrient != "base") %>%
    group_by(nutrient) %>%
    summarise(
      avg_contribution = round(mean(as.numeric(contributions)),2), 
      min_contribution = round(min(as.numeric(contributions)),2),
      max_contribution = round(max(as.numeric(contributions)),2)
    ) %>%
    arrange(desc(abs(avg_contribution))) %>%
    select(nutrient, min_contribution, max_contribution) %>%
    # Rename the columns to include the concentration name
    rename_with(~ paste0(.x, "_", conc), -nutrient)
})

# Merge the summary data frames into a single data frame
strategy_summary.df <- reduce(summary_dfs, full_join, by = "nutrient")

strategy_summary.df <- strategy_summary.df %>%
  left_join(mean_contributions, by = "nutrient") %>%
  arrange(desc(mean_abs_contribution))

# ShortDescription comes from mean_contributions
strategy_summary.df$nutrient <- strategy_summary.df$ShortDescription
strategy_summary.df <- strategy_summary.df[order(strategy_summary.df$mean_abs_contribution, decreasing = TRUE),]
strategy_summary.df <- subset(strategy_summary.df, select = c(1:7))

kable(strategy_summary.df, "latex", escape = F, booktabs = T, row.names = FALSE, digits = 2,align="lcccccc",
  col.names = c("Nutrient", "Min", "Max", "Min", "Max", "Min", "Max")) %>%
  add_header_above(c(" " = 1, "P-K" = 2, "fP-Pi" = 2, "P-Alb" = 2), escape = F) %>%
  column_spec(1, width = "7em") %>%
  kable_styling(latex_options="scale_down") %>%  
  kable_styling(latex_options = c("basic", "condensed"), full_width = TRUE) %>%
  row_spec(0,bold=TRUE) %>%
  save_kable(file = "tables/dialysis_diet_strategies.pdf", keep_tex = TRUE)

```


```{r diet_strategies_table_percentages}
library(dplyr)
library(tidyr)
library(purrr)
library(kableExtra)

# Get unique concentrations
concentrations <- unique(cumulative_concs$concentration)

# Loop through each concentration and create summary statistics
summary_dfs <- lapply(concentrations, function(conc) {
  cumulative_concs %>%
  ungroup() %>%
    select(nutrient, concentration, contributions, predicted_concentration) %>%
    filter(concentration == conc) %>%
    filter(nutrient != "base") %>%
    mutate(contribution_percentage = as.numeric(contributions) / predicted_concentration * 100) %>%
    group_by(nutrient) %>%
    summarise(
      min_percentage = paste0(round(min(contribution_percentage),1),"%"),
      max_percentage = paste0(round(max(contribution_percentage),1),"%"),
      avg_percentage = paste0(round(mean(contribution_percentage),1),"%")
    ) %>%
    select(nutrient, min_percentage, max_percentage) %>%
    rename_with(~ paste0(.x, "_", conc), -nutrient)
})

# Merge the summary data frames into a single data frame
strategy_summary.df <- reduce(summary_dfs, full_join, by = "nutrient")

strategy_summary.df <- strategy_summary.df %>%
  left_join(mean_contributions, by = "nutrient") %>%
  arrange(desc(mean_abs_contribution))

# ShortDescription comes from mean_contributions
strategy_summary.df$nutrient <- strategy_summary.df$ShortDescription
strategy_summary.df <- strategy_summary.df[order(strategy_summary.df$mean_abs_contribution, decreasing = TRUE),]
strategy_summary.df <- subset(strategy_summary.df, select = c(1:7))

kable(strategy_summary.df, "latex", escape = F, booktabs = T, row.names = FALSE, digits = 2,align="lcccccc",
  col.names = c("Nutrient", "Min", "Max", "Min", "Max", "Min", "Max")) %>%
  add_header_above(c(" " = 1, "P-K" = 2, "fP-Pi" = 2, "P-Alb" = 2), escape = F) %>%
  column_spec(1, width = "7em") %>%
  row_spec(0,bold=TRUE) %>%
  kable_styling(latex_options="scale_down") %>%  
  kable_styling(latex_options = c("basic", "condensed"), full_width = TRUE) %>%
  save_kable(file = "tables/dialysis_diet_strategies_percentages.pdf", keep_tex = TRUE)


```

````{r}
# Testing percentages

cumulative_concs %>%
   ungroup() %>%
   filter(nutrient == "epa" & concentration == "fsins") %>%
   arrange(desc(contributions)) %>%
   select(person_id, contributions, predicted_concentration) %>%
   mutate(percentage = as.numeric(contributions) / predicted_concentration * 100) %>%
   arrange(desc(percentage))

cumulative_concs

```

# TRASHCAN


```{r recommendation_analysis}
library(dplyr)
library(tibble)
library(tidyr)
library(igraph)
library(stringr)
library(ggplot2)

intake.df <- readRDS("patient_summary/dialysis/mv3_cross_two_levels/simulationX50_B50_A50_I50/recommendation_summary_with_concpreds_and_current.rds")

datadesc <- dialysis_datadesc
assumedpredictors <- dialysis_predictors

org_stats <- data.frame(name = subset(assumedpredictors$Name, assumedpredictors$Distribution == "Gaussian"))
org_stats$mean <- sapply(org_stats$name, function(x) mean(dialysis[[x]]))
org_stats$sd <- sapply(org_stats$name, function(x) sd(dialysis[[x]]))

nutrient_names <- colnames(intake.df)[4:(4+12)]

# - transform all intake to normalized scale
for (idx in 1:length(nutrient_names)) {
  n <- org_stats[idx,]$name
  cn <- paste0("current_",org_stats[idx,]$name)
  
  intake.df[[n]] <- (intake.df[[n]] - org_stats[org_stats$name == n,]$mean) / org_stats[org_stats$name == n,]$sd
  intake.df[[cn]] <- (intake.df[[cn]] - org_stats[org_stats$name == n,]$mean) / org_stats[org_stats$name == n,]$sd
}

change_analysis.df <- intake.df %>%
  mutate(across(
    .cols = all_of(nutrient_names),
    .fns = function(x) {
      current_col <- get(paste0("current_", cur_column()))
      x - current_col
    },
    .names = "{col}_change"
  )) %>%
  select(subject_code, nutrient_names, ends_with("_change")) %>%
  tidyr::gather(nutrient, change, -subject_code, -nutrient_names) %>%
  mutate(nutrient = str_replace(nutrient, "_change", "")) %>%
  select(subject_code, nutrient, change)

# new column for nutrients effect in fixing the concentrations 
change_analysis.df$interaction_effect <- 0
change_analysis.df$pk_effect <- 0
change_analysis.df$fppi_effect <- 0
change_analysis.df$palb_effect <- 0
change_analysis.df$pk_gap <- 0
change_analysis.df$fppi_gap <- 0
change_analysis.df$palb_gap <- 0

# loop all patients
for (subject_code in intake.df$subject_code) {
  person_id <- match(subject_code, levels(dialysis$potilas))

  # joint_effect is calculated as a sum of interactions between nutrients effect on concentrations and current gap in concentration
  
  # - get personal effects from graphs
  graph_dir <- paste0("graphs/dialysis/mv3_cross_two_levels/",person_id)
  personal_graph <- read.graph(paste0(graph_dir, "/personal_graph.graphml"), "graphml")
  
  for (nutrient in nutrient_names) {
  
    pk_effect <- V(personal_graph)[paste0("personal_", nutrient, "_", "pk")]$value
    fppi_effect <- V(personal_graph)[paste0("personal_", nutrient, "_", "fppi")]$value
    palb_effect <- V(personal_graph)[paste0("personal_", nutrient, "_", "palb")]$value
    
    change_analysis.df[change_analysis.df$subject_code == subject_code & change_analysis.df$nutrient == nutrient,]$pk_effect <- pk_effect
    change_analysis.df[change_analysis.df$subject_code == subject_code & change_analysis.df$nutrient == nutrient,]$fppi_effect <- fppi_effect
    change_analysis.df[change_analysis.df$subject_code == subject_code & change_analysis.df$nutrient == nutrient,]$palb_effect <- palb_effect
    
  }
  
  # - get personal gaps in concentrations
  intake_recommendation.df <- intake.df[intake.df$subject_code == subject_code,]
  
  personal_info <- head(dialysis[dialysis$potilas == subject_code,],1)
  
  recommeded_concentrations <- mebn.get_personal_dialysis_guidelines(personal_info, patient_in_dialysis = TRUE)
  pk_min <- recommeded_concentrations$lower_limits[1]
  fppi_min <- recommeded_concentrations$lower_limits[2]
  palb_min <- recommeded_concentrations$lower_limits[3]
  pk_max <- recommeded_concentrations$upper_limits[1]
  fppi_max <- recommeded_concentrations$upper_limits[2]
  palb_max <- recommeded_concentrations$upper_limits[3]
  
  # gaps should be also normalized to 0..1 scale

  pk_gap <- max(0, pk_min - intake_recommendation.df$current_pk)
  pk_gap <- pk_gap + max(0, intake_recommendation.df$current_pk - pk_max)
  
  fppi_gap <- max(0, fppi_min - intake_recommendation.df$current_fppi)
  fppi_gap <- fppi_gap + max(0, intake_recommendation.df$current_fppi - fppi_max)
  
  palb_gap <- max(0, palb_min - intake_recommendation.df$current_palb)
  palb_gap <- palb_gap + max(0, intake_recommendation.df$current_palb - palb_max)
  
  max_gap <- max(pk_gap, fppi_gap, palb_gap)

  normalized_pk_gap <- pk_gap / max_gap
  normalized_fppi_gap <- fppi_gap / max_gap
  normalized_palb_gap <- palb_gap / max_gap

  change_analysis.df[change_analysis.df$subject_code == subject_code,]$pk_gap <- normalized_pk_gap
  change_analysis.df[change_analysis.df$subject_code == subject_code,]$fppi_gap <- normalized_fppi_gap
  change_analysis.df[change_analysis.df$subject_code == subject_code,]$palb_gap <- normalized_palb_gap
}

# - calculate interaction effect of nutrient for all patients
change_analysis.df$joint_effect <- abs(change_analysis.df$pk_effect) * change_analysis.df$pk_gap + abs(change_analysis.df$fppi_effect) * change_analysis.df$fppi_gap + abs(change_analysis.df$palb_effect) * change_analysis.df$palb_gap

ggplot(change_analysis.df) + geom_point(aes(y=abs(change), x=joint_effect, color=nutrient), size = 2, show.legend = TRUE)

c382 <- change_analysis.df[change_analysis.df$subject_code==382,]

ggplot(change_analysis.df, aes(x = nutrient, y = change)) +
  geom_bar(stat = "identity", aes(fill = change < 0)) +
  labs(x = "Nutrient", y = "Normalized change", title = "") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

nutrients <- datadesc[datadesc$Name %in% unique(change_analysis.df$nutrient),]
nutrient_labels <- paste0(nutrients$ShortDescription, " (", nutrients$Unit, ")")

change_analysis.df <- change_analysis.df %>% inner_join(datadesc, join_by(nutrient == Name))
change_analysis.df$nutrient_label <- paste0(change_analysis.df$ShortDescription, " (", change_analysis.df$Unit, ")")
  
recdist <- ggplot(change_analysis.df, aes(y = nutrient_label, x = change)) +
  geom_boxplot(color="black", aes(fill = change < 0), show.legend = FALSE) +
  labs(y = "Nutrient", x = "Normalized change") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) 

ggsave(paste0("figures/dialysis_recommedation_distribution.pdf"), plot = recdist, scale = 0.5)

```

```{r}
recommendation_intake.df <- readRDS("patient_summary/dialysis/mv3_cross_two_levels/simulationX50_B50_A50_I50/details/recommendation_intake_1.rds")

datadesc <- dialysis_datadesc
assumedpredictors <- dialysis_predictors

org_stats <- data.frame(name = subset(assumedpredictors$Name, assumedpredictors$Distribution == "Gaussian"))
org_stats$mean <- sapply(org_stats$name, function(x) mean(dialysis[[x]]))
org_stats$sd <- sapply(org_stats$name, function(x) sd(dialysis[[x]]))

nutrient_names <- colnames(recommendation_intake.df)[8:(8+12)]

# - transform all intake to normalized scale
for (idx in 1:length(nutrient_names)) {
  n <- org_stats[idx,]$name

  recommendation_intake.df[[n]] <- (recommendation_intake.df[[n]] - org_stats[org_stats$name == n,]$mean) / org_stats[org_stats$name == n,]$sd
}

# ggplot(recommendation_intake.df) +
#   geom_point(aes(y = lp, x = sakkaroosiepros, color = 1)) +
#   geom_point(aes(y = lp, x = protepros, color = 2)) +
#   geom_point(aes(y = lp, x = hhepros, color = 3)) +
#   geom_point(aes(y = lp, x = safaepros, color = 4)) +
#   geom_point(aes(y = lp, x = mufaepros, color = 5)) +
#   geom_point(aes(y = lp, x = pufaepros, color = 6)) +
#   geom_point(aes(y = lp, x = kuitu, color = 7)) +
#   geom_point(aes(y = lp, x = dvit, color = 8)) +
#   geom_point(aes(y = lp, x = kalsium, color = 9)) +
#   geom_point(aes(y = lp, x = kalium, color = 10)) +
#   geom_point(aes(y = lp, x = suola, color = 11)) +
#   geom_point(aes(y = lp, x = fosfori, color = 12)) +
#   geom_point(aes(y = lp, x = vesi, color = 13)) 


ggplot(recommendation_intake.df) +
   geom_point(aes(y = palb, x = kuitu, color = preference))

recommendation_intake.df

```



```{r}
library(kableExtra)

patient_summary <- readRDS("patient_summary/dialysis/mv3_cross_two_levels/simulationX50_B50_A50_I50/recommendation_summary.rds")

recommendation_table.df <- data.frame(person_id <- as.numeric(patient_summary$person_id), row.names = NULL)

recommendation_table.df$protepros <- linebreak(paste0(format(round(as.numeric(patient_summary$protepros),2), nsmall = 2),"\n$\\left[",format(round(as.numeric(patient_summary$protepros_lCI),2), nsmall = 2),"; ",format(round(as.numeric(patient_summary$protepros_uCI),2), nsmall = 2),"\\right]$"), align = "c")

recommendation_table.df$hhepros <- linebreak(paste0(format(round(as.numeric(patient_summary$hhepros),2), nsmall = 2),"\n$\\left[",format(round(as.numeric(patient_summary$hhepros_lCI),2), nsmall = 2),"; ",format(round(as.numeric(patient_summary$hhepros_uCI),2), nsmall = 2),"\\right]$"), align = "c")

recommendation_table.df$safaepros <- linebreak(paste0(format(round(as.numeric(patient_summary$safaepros),2), nsmall = 2),"\n$\\left[",format(round(as.numeric(patient_summary$safaepros_lCI),2), nsmall = 2),"; ",format(round(as.numeric(patient_summary$safaepros_uCI),2), nsmall = 2),"\\right]$"), align = "c")

recommendation_table.df$mufaepros <- linebreak(paste0(format(round(as.numeric(patient_summary$mufaepros),2), nsmall = 2),"\n$\\left[",format(round(as.numeric(patient_summary$mufaepros_lCI),2), nsmall = 2),"; ",format(round(as.numeric(patient_summary$mufaepros_uCI),2), nsmall = 2),"\\right]$"), align = "c")

recommendation_table.df$pufaepros <- linebreak(paste0(format(round(as.numeric(patient_summary$pufaepros),2), nsmall = 2),"\n$\\left[",format(round(as.numeric(patient_summary$pufaepros_lCI),2), nsmall = 2),"; ",format(round(as.numeric(patient_summary$pufaepros_uCI),2), nsmall = 2),"\\right]$"), align = "c")

recommendation_table.df$kuitu <- linebreak(paste0(format(round(as.numeric(patient_summary$kuitu),2), nsmall = 2),"\n$\\left[",format(round(as.numeric(patient_summary$kuitu_lCI),2), nsmall = 2),"; ",format(round(as.numeric(patient_summary$kuitu_uCI),2), nsmall = 2),"\\right]$"), align = "c")

recommendation_table.df$dvit <- linebreak(paste0(format(round(as.numeric(patient_summary$dvit),2), nsmall = 2),"\n$\\left[",format(round(as.numeric(patient_summary$dvit_lCI),2), nsmall = 2),"; ",format(round(as.numeric(patient_summary$dvit_uCI),2), nsmall = 2),"\\right]$"), align = "c")

recommendation_table.df$natrium <- linebreak(paste0(format(round(as.numeric(patient_summary$natrium),2), nsmall = 2),"\n$\\left[",format(round(as.numeric(patient_summary$natrium_lCI),2), nsmall = 2),"; ",format(round(as.numeric(patient_summary$natrium_uCI),2), nsmall = 2),"\\right]$"), align = "c")

recommendation_table.df$kalsium <- linebreak(paste0(format(round(as.numeric(patient_summary$kalsium),2), nsmall = 2),"\n$\\left[",format(round(as.numeric(patient_summary$kalsium_lCI),2), nsmall = 2),"; ",format(round(as.numeric(patient_summary$kalsium_uCI),2), nsmall = 2),"\\right]$"), align = "c")

recommendation_table.df$kalium <- linebreak(paste0(format(round(as.numeric(patient_summary$kalium),2), nsmall = 2),"\n$\\left[",format(round(as.numeric(patient_summary$kalium_lCI),2), nsmall = 2),"; ",format(round(as.numeric(patient_summary$kalium_uCI),2), nsmall = 2),"\\right]$"), align = "c")

recommendation_table.df$suola <- linebreak(paste0(format(round(as.numeric(patient_summary$suola),2), nsmall = 2),"\n$\\left[",format(round(as.numeric(patient_summary$suola_lCI),2), nsmall = 2),"; ",format(round(as.numeric(patient_summary$suola_uCI),2), nsmall = 2),"\\right]$"), align = "c")

recommendation_table.df$fosfori <- linebreak(paste0(format(round(as.numeric(patient_summary$fosfori),2), nsmall = 2),"\n$\\left[",format(round(as.numeric(patient_summary$fosfori_lCI),2), nsmall = 2),"; ",format(round(as.numeric(patient_summary$fosfori_uCI),2), nsmall = 2),"\\right]$"), align = "c")

recommendation_table.df$vesi <- linebreak(paste0(format(round(as.numeric(patient_summary$vesi),2), nsmall = 2),"\n$\\left[",format(round(as.numeric(patient_summary$vesi_lCI),2), nsmall = 2),"; ",format(round(as.numeric(patient_summary$vesi_uCI),2), nsmall = 2),"\\right]$"), align = "c")

kable(recommendation_table.df, format = "latex", escape = F, booktabs = T, row.names = FALSE, digits = 2,
   caption = "Personally recommended intake (RI) for renal patients with lower and upper limits of recommendations.",
   col.names = c("Person", "Protein (g/d)", "Carbonhydrates (E%)", "SFA (E%)", "MUFA (E%)", "PUFA (E%)", "Fiber (g/d)", "Vitamin D (ug/d)", "Sodium (mg/d)", "Calcium (mg/d)", "Potassium (mg/d)", "Salt (mg/d)", "Phosphorous (mg/d)", "Water (ml/d)")) %>%
   kable_styling(latex_options="scale_down") %>%  
   kable_styling(latex_options = c("basic", "condensed"), full_width = FALSE) %>%
   row_spec(0,bold=TRUE) %>%
   save_kable(file = "tables/recommendations_dialysis.pdf", keep_tex = TRUE)

```


```{r}
library(ggplot2)
library(gridExtra)
library(rstan)

result <- rstan::extract(intake_model)

proposal <- 1:length(result$lp__)

df <- data.frame(proposal=proposal, lp=result$lp__, pk_mu=result$pk_mu-1000, fppi_mu=result$fppi_mu-1000, palb_mu=result$palb_mu-1000, preference=result$preference, Q1=result$Q[,1])

conc_plot1 <- ggplot(df) +
  geom_point(aes(y=lp, x=pk_mu, color=preference)) +
  geom_vline(xintercept = pk_recommendations, linetype="solid", color = "black", size=0.4) +
  scale_color_gradientn(colours = colorspace::diverge_hcl(7))

conc_plot2 <- ggplot(df) +
  geom_point(aes(y=lp, x=fppi_mu, color=preference)) +
  geom_vline(xintercept = fppi_recommendations, linetype="solid", color = "black", size=0.4) +
  scale_color_gradientn(colours = colorspace::diverge_hcl(7))

conc_plot3 <- ggplot(df) +
  geom_point(aes(y=lp, x=palb_mu, color=preference)) +
  geom_vline(xintercept = palb_recommendations, linetype="solid", color = "black", size=0.4) +
  scale_color_gradientn(colours = colorspace::diverge_hcl(7))

lay <- rbind(c(1),
             c(2),
             c(3))

lp_plot <- grid.arrange(conc_plot1, conc_plot2, conc_plot3, layout_matrix = lay, padding=0)

ggsave(paste0("figures/personal_recommendations/log_probability_",person_id,".pdf"), plot = lp_plot)

```


```{r party, cache=FALSE, eval=TRUE, echo=FALSE,message=FALSE, warning=FALSE, fig.height=12, fig.width=8, fig.cap="The figure is plotted with ggplot2 package for R language (v 3.3.5, https://ggplot2.tidyverse.org)."}
library(ggplot2)
library(gridExtra)
library(ggrepel)
library(dplyr)
library(igraph)

graph_dir <- "graphs/dialysis/mv3_cross_two_levels/"

# Plot the personal recommendations
for (person_id in 1:37) {
  
  #person_id <- 2
  
  subject_code <- levels(dialysis$potilas)[person_id]

  personal_info <- head(dialysis[dialysis$potilas == subject_code,],1)
  recommeded_concentrations <- mebn.get_personal_dialysis_guidelines(personal_info, patient_in_dialysis = TRUE)
  
  # get personal graph for plotting the current intake
  personal_model_dir <- paste0(graph_dir,person_id)
  personal_graph <- read.graph(paste0(personal_model_dir, "/personal_graph.graphml"), "graphml")

  pk_recommendations <- c(recommeded_concentrations$lower_limits[1], recommeded_concentrations$upper_limits[1])
  fppi_recommendations <- c(recommeded_concentrations$lower_limits[2], recommeded_concentrations$upper_limits[2])
  palb_recommendations <- c(recommeded_concentrations$lower_limits[3], recommeded_concentrations$upper_limits[3])
    
  simulation <- "X50_B50_A50_I50"
  
  accepted_intake <- paste0("./patient_summary/dialysis/mv3_cross_two_levels/simulation",simulation,"/details/accepted_intake_",person_id,".rds")
  recommendation_intake <- paste0("./patient_summary/dialysis/mv3_cross_two_levels/simulation",simulation,"/details/recommendation_intake_",person_id,".rds")
  
  if (file.exists(recommendation_intake)) {

    recommendation_intake.df <- readRDS(recommendation_intake)
    
    # Plotting
    cond_intake_names <- colnames(recommendation_intake.df)[9:ncol(recommendation_intake.df)]
    
    prior_index <- ncol(recommendation_intake.df)
    
    number_of_cond_intake <- length(cond_intake_names)
    intake_plots <- myplots <- vector('list', number_of_cond_intake)
    
    for (i in 1:number_of_cond_intake)
    {
      intake_name <- cond_intake_names[i]
      intake_symbol <- ensym(intake_name)
      
      proposal_intake_name <- paste0(cond_intake_names[i], "_proposal")
      proposal_intake_symbol <- ensym(proposal_intake_name)
      
      variable_desc <- dialysis_datadesc[dialysis_datadesc$Name == intake_name,]

      #ScaleMin <- as.numeric(variable_desc$ScaleMin)
      #ScaleMax <- as.numeric(variable_desc$ScaleMax)

      ScaleMin <- as.numeric(variable_desc$Lowerbound)
      ScaleMax <- as.numeric(variable_desc$Upperbound)
      
      ScaleBreaks <- seq(from = ScaleMin, to = ScaleMax, by = (ScaleMax - ScaleMin) / 5)
      
      general_RI <- as.numeric(variable_desc$Recommendation)
      
      intake_node <- V(personal_graph)[intake_name]
      
      current_intake <- 0
      if (startsWith(intake_node$distribution, "N"))
      {
          # get current intake from mean of intake normal distribution
          current_intake <- as.numeric(str_extract(intake_node$distribution,"(?<=N\\().+(?=,)")) # N(*,
      } 

      personal_RI <- mean(recommendation_intake.df[[intake_symbol]])
      
      # sample from proposal distribution
      #recommendation_intake.df[[proposal_intake_name]] <- c(rnorm(4000, mean=general_RI, sd=(ScaleMax-ScaleMin)/10))

      intake_plot <- ggplot(recommendation_intake.df) + 
        #geom_density(aes(x = !!proposal_intake_symbol), fill = "#00FF88", colour = "#002222", alpha = 0.3, show.legend = FALSE) +
        geom_density(aes(x = !!intake_symbol), fill = "#0000FF", colour = "#0000FF", alpha = 0.2, show.legend = FALSE) +
        labs(x = paste0(variable_desc$Description, " (", variable_desc$Unit,")"), y = "", size = 1.2) +
        geom_vline(xintercept = current_intake, linetype="dashed", color = "black", size=0.5) +
        geom_vline(xintercept = personal_RI, linetype="solid", color = "black", size=0.5) +
        scale_x_continuous(limits=c(ScaleMin,ScaleMax), breaks=ScaleBreaks) +
        theme_bw() +
        theme(axis.text.y = element_blank())
        
      intake_plots[[i]] <- intake_plot
    }

    recommendation_plot <- grid.arrange(grobs = intake_plots, ncol=1, padding=0)

    #ggsave(paste0("figures/personal_recommendations/dialysis_recommendation_",person_id,".pdf"), plot = recommendation_plot, width = 6, height = 6, scale = 1)
    ggsave(paste0("figures/personal_recommendations/dialysis/dialysis_recommendation_",person_id,".pdf"), plot = recommendation_plot, scale = 1)
    
  } # file exists
}

```

```{r}
      intake_plot <- ggplot(subset(accepted_intake.df, lowest_conc_prob >= 0.50), aes(x = kalium, y = fosfori)) +
        geom_point(aes(colour=lowest_conc_prob), show.legend = TRUE) +
        labs(x = "Potassium (mg/d)", y = "Phosphorous (mg/d)") +
        scale_colour_gradient2(low = "#FFFFFF",
                               high = "#0096FF",
                               midpoint = 0.75,
                               breaks = seq(0.5, 1, by = 0.05),
                               limits = c(0.5, 1),
                               labels = as.character(seq(50, 100, by = 5))) +
        scale_x_continuous(limits=c(0,5800), breaks=c(0,1000,2000,3000,4000,5000,5800)) +
        scale_y_continuous(limits=c(0,2550), breaks=c(0,500,1000,1500,2000,2550)) + 
        theme(legend.position="bottom", axis.text = element_text(size=6), axis.title = element_text(size=8), plot.title = element_text(size=10)) + 
        guides(colour = guide_colorbar(title = "Probability % of reaching target concentrations", title.theme = element_text(size=8), label.theme = element_text(size=6), title.position = "top", barwidth = unit(80,"mm"))) 
    
      intake_plot
```


## TRASHCAN

```{r concentration_predictions}
  library(rstan)
  library(igraph)
  library(stringr)
  
  source("mebn/v3/MEBNv3.r")

  queried_nodes <- dialysis_datadesc[dialysis_datadesc$Condition >= 100,]$Name
  patient_summary <- readRDS("patient_summary/dialysis/mv3_cross_two_levels/simulationX50_B50_A50_I50/recommendation_summary.rds")

  for (subject_id in 1:37) {
    
    print(subject_id)

    graph_dir <- paste0("graphs/dialysis/mv3_cross_two_levels/",subject_id)
    reaction_graph <- read.graph(paste0(graph_dir, "/personal_graph.graphml"), "graphml")
    
    org_stats <- data.frame(name = subset(dialysis_predictors$Name, dialysis_predictors$Distribution == "Gaussian"))
    org_stats$mean <- sapply(org_stats$name, function(x) mean(dialysis[[x]]))
    org_stats$sd <- sapply(org_stats$name, function(x) sd(dialysis[[x]]))
  
    queried_nodes <- dialysis_datadesc[dialysis_datadesc$Condition >= 100,]$Name
    queried_nodes_lCI <- paste0(queried_nodes,"_lCI")
    queried_nodes_uCI <- paste0(queried_nodes,"_uCI")
  
    params <- mebn.extract_parameters_from_graph(reaction_graph, beta_point_est = "mean", param_point_est = "mean", X_point_est = "mean", queried_nodes = queried_nodes)
    
    Q_values <- patient_summary %>% filter(person_id == subject_id) %>% select(all_of(queried_nodes))
    Q_values_lCI <- patient_summary %>% filter(person_id == subject_id) %>% select(all_of(queried_nodes_lCI))
    Q_values_uCI <- patient_summary %>% filter(person_id == subject_id) %>% select(all_of(queried_nodes_uCI))
    
    Q_values_norm <- (as.numeric(Q_values) - org_stats[org_stats$name == colnames(Q_values),]$mean) / org_stats[org_stats$name == colnames(Q_values),]$sd
    Q_values_lCI_norm <- (as.numeric(Q_values_lCI) - org_stats[org_stats$name == colnames(Q_values),]$mean) / org_stats[org_stats$name == colnames(Q_values),]$sd
    Q_values_uCI_norm <- (as.numeric(Q_values_uCI) - org_stats[org_stats$name == colnames(Q_values),]$mean) / org_stats[org_stats$name == colnames(Q_values),]$sd
    
    pk_mu <- params$intercept_point[1] + params$X_evidence_point %*% params$X_beta_point[1,] + Q_values_norm %*% params$Q_beta_point[1,]
    fppi_mu <- params$intercept_point[2] + params$X_evidence_point %*% params$X_beta_point[2,] + Q_values_norm %*% params$Q_beta_point[2,]
    palb_mu <- params$intercept_point[3] + params$X_evidence_point %*% params$X_beta_point[3,] + Q_values_norm %*% params$Q_beta_point[3,]
    
    resulting_conc_mu <- c(pk_mu,fppi_mu,palb_mu)
  
    quant_limit <- 0.9
    pk_mu_lCI <- qgamma(1-quant_limit, shape=params$alpha_point[1], rate=params$alpha_point[1]/pk_mu)
    pk_mu_uCI <- qgamma(quant_limit, shape=params$alpha_point[1], rate=params$alpha_point[1]/pk_mu)

    fppi_mu_lCI <- qgamma(1-quant_limit, shape=params$alpha_point[2], rate=params$alpha_point[2]/fppi_mu)
    fppi_mu_uCI <- qgamma(quant_limit, shape=params$alpha_point[2], rate=params$alpha_point[2]/fppi_mu)

    palb_mu_lCI <- qgamma(1-quant_limit, shape=params$alpha_point[3], rate=params$alpha_point[3]/palb_mu)
    palb_mu_uCI <- qgamma(quant_limit, shape=params$alpha_point[3], rate=params$alpha_point[3]/palb_mu)

    resulting_conc_mu_lCI <- c(pk_mu_lCI,fppi_mu_lCI,palb_mu_lCI)
    resulting_conc_mu_uCI <- c(pk_mu_uCI,fppi_mu_uCI,palb_mu_uCI)
    
    patient_summary[patient_summary$person_id == subject_id,]$pk <- pk_mu
    patient_summary[patient_summary$person_id == subject_id,]$pk_lCI <- pk_mu_lCI
    patient_summary[patient_summary$person_id == subject_id,]$pk_uCI <- pk_mu_uCI
  
    patient_summary[patient_summary$person_id == subject_id,]$fppi <- fppi_mu
    patient_summary[patient_summary$person_id == subject_id,]$fppi_lCI <- fppi_mu_lCI
    patient_summary[patient_summary$person_id == subject_id,]$fppi_uCI <- fppi_mu_uCI
  
    patient_summary[patient_summary$person_id == subject_id,]$palb <- palb_mu
    patient_summary[patient_summary$person_id == subject_id,]$palb_lCI <- palb_mu_lCI
    patient_summary[patient_summary$person_id == subject_id,]$palb_uCI <- palb_mu_uCI
    
  }
  
  saveRDS(patient_summary, paste0("patient_summary/dialysis/mv3_cross_two_levels/simulationX50_B50_A50_I50/recommendation_summary_with_concpreds.rds"))

```

```{r}
source("mebn/v3/MEBNv3.r")

process_limits <- function(df) {
  
  conc_limits <- mebn.get_personal_dialysis_guidelines(df, patient_in_dialysis = TRUE)
  
  subject <- df[["potilas"]]
  pk_max <- conc_limits$upper_limits[1]
  fppi_max <- conc_limits$upper_limits[2]
  palb_max <- conc_limits$upper_limits[3]
  pk_min <- conc_limits$lower_limits[1]
  fppi_min <- conc_limits$lower_limits[2]
  palb_min <- conc_limits$lower_limits[3]
  
  c(subject, pk_min, pk_max, fppi_min, fppi_max, palb_min, palb_max)
}

limits <- apply(dialysis[dialysis$havainto == 1,], 1, process_limits)

conc_limits <- data.frame(t(limits))
colnames(conc_limits) <- c("potilas", "pk_min", "pk_max", "fppi_min", "fppi_max", "palb_min", "palb_max")
conc_limits$pk_min <- as.numeric(conc_limits$pk_min)
conc_limits$pk_max <- as.numeric(conc_limits$pk_max)
conc_limits$fppi_min <- as.numeric(conc_limits$fppi_min)
conc_limits$fppi_max <- as.numeric(conc_limits$fppi_max)
conc_limits$palb_min <- as.numeric(conc_limits$palb_min)
conc_limits$palb_max <- as.numeric(conc_limits$palb_max)

dialysis %>% 
  group_by(potilas) %>%
  summarize(pk_avg = mean(pk), fppi_avg = mean(fppi), palb_avg = mean(palb)) %>%
  inner_join(conc_limits, by = "potilas") %>%
  mutate(pk_valid = ifelse(pk_avg >= pk_min & pk_avg <= pk_max, "Yes", "No")) %>%
  mutate(fppi_valid = ifelse(fppi_avg >= fppi_min & fppi_avg <= fppi_max, "Yes", "No")) %>%
  mutate(palb_valid = ifelse(palb_avg >= palb_min & palb_avg <= palb_max, "Yes", "No")) %>%
  select(potilas, pk_avg, pk_valid, fppi_avg, fppi_valid, palb_avg, palb_valid) %>%
  arrange(pk_valid, fppi_valid, palb_valid)

```

